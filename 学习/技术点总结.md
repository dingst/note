1、在 Java 中，有以下几种对象可以作为 GC Root：

Java 虚拟机栈（局部变量表）中的引用的对象。
方法区中静态引用指向的对象。
仍处于存活状态中的线程对象。
Native 方法中 JNI 引用的对象。


2、GC 实现都会在以下两种情况下触发垃圾回收。

Allocation Failure：在堆内存中分配时，如果因为可用剩余空间不足导致对象内存分配失败，这时系统会触发一次 GC。
System.gc()：在应用层，Java 开发工程师可以主动调用此 API 来请求一次 GC。

3、-Xms 初始分配 JVM 运行时的内存大小，如果不指定默认为物理内存的 1/64


4、垃圾回收几种方法：

标记清除算法（Mark and Sweep GC）
从”GC Roots”集合开始，将内存整个遍历一次，保留所有可以被 GC Roots 直接或间接引用到的对象，而剩下的对象都当作垃圾对待并回收，过程分两步。

Mark 标记阶段：找到内存中的所有 GC Root 对象，只要是和 GC Root 对象直接或者间接相连则标记为灰色（也就是存活对象），否则标记为黑色（也就是垃圾对象）。
Sweep 清除阶段：当遍历完所有的 GC Root 之后，则将标记为垃圾的对象直接清除。

优点：实现简单，不需要将对象进行移动。
缺点：这个算法需要中断进程内其他组件的执行（stop the world），并且可能产生内存碎片，提高了垃圾回收的频率。

复制算法（Copying）
将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中。之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。

复制算法之前，内存分为 A/B 两块，并且当前只使用内存 A
标记完之后，所有可达对象都被按次序复制到内存 B 中，并设置 B 为当前使用中的内存。
优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。
缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。

标记-压缩算法 (Mark-Compact)
需要先从根节点开始对所有可达对象做一次标记，之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。最后，清理边界外所有的空间。因此标记压缩也分两步完成：
Mark 标记阶段：找到内存中的所有 GC Root 对象，只要是和 GC Root 对象直接或者间接相连则标记为灰色（也就是存活对象），否则标记为黑色（也就是垃圾对象）。
Compact 压缩阶段：将剩余存活对象按顺序压缩到内存的某一端。
优点：这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。
缺点：所谓压缩操作，仍需要进行局部对象移动，所以一定程度上还是降低了效率。

新生代采用复制算法，老年代采用标记压缩算法。

5、JVM 规范中严格规定了 class 初始化的时机，主要有以下几种情况会触发 class 的初始化：

虚拟机启动时，初始化包含 main 方法的主类；

遇到 new 指令创建对象实例时，如果目标对象类没有被初始化则进行初始化操作；

当遇到访问静态方法或者静态字段的指令时，如果目标对象类没有被初始化则进行初始化操作；

子类的初始化过程如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化；

使用反射 API 进行反射调用时，如果类没有进行过初始化则需要先触发其初始化；

第一次调用 java.lang.invoke.MethodHandle 实例时，需要初始化 MethodHandle 指向方法所在的类。

6、对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过子类 Child 来引用父类 Parent 中定义的静态字段，只会触发父类 Parent 的初始化而不会触发子类 Child 的初始化。
虽然只有 Parent 被初始化，但是 Parent 和 Child 都经过了装载和验证阶段，并被加载到内存中。

7、对象的初始化顺序如下：
静态变量/静态代码块 -> 普通代码块 -> 构造函数

1. 父类静态变量和静态代码块；

2. 子类静态变量和静态代码块；

3. 父类普通成员变量和普通代码块；

4. 父类的构造函数；

5. 子类普通成员变量和普通代码块；

6. 子类的构造函数。


8、


